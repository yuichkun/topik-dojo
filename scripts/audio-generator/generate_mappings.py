import os
import json
from datetime import datetime
import re


def sanitize_filename(filename):
    """Sanitize filename by replacing invalid characters"""
    # Replace invalid filesystem characters with underscore
    invalid_chars = r'[<>:"/\\|?*]'
    return re.sub(invalid_chars, '_', filename)


def scan_audio_files(audio_dir):
    """Scan the audio directory and return sets of existing files"""
    words_dir = os.path.join(audio_dir, "words")
    examples_dir = os.path.join(audio_dir, "examples")
    
    word_files = set()
    example_files = set()
    
    # Scan word audio files
    if os.path.exists(words_dir):
        for filename in os.listdir(words_dir):
            if filename.endswith('.mp3'):
                # Remove .mp3 extension to get the korean word
                korean = filename[:-4]
                word_files.add(korean)
    
    # Scan example audio files
    if os.path.exists(examples_dir):
        for filename in os.listdir(examples_dir):
            if filename.endswith('.mp3'):
                # Remove .mp3 extension to get the korean word
                korean = filename[:-4]
                example_files.add(korean)
    
    return word_files, example_files


def create_audio_mappings(word_files, example_files):
    """Create the JavaScript mapping file for audio assets"""
    mappings_path = os.path.join(
        os.path.dirname(__file__), "..", "..", "src", "assets", "audioMappings.js"
    )
    
    # Read words.json to get the full list and validate
    words_path = os.path.join(
        os.path.dirname(__file__), "..", "..", "src", "assets", "words.json"
    )
    with open(words_path, "r", encoding="utf-8") as f:
        words_data = json.load(f)
    
    # Create sets of expected sanitized filenames from words.json
    expected_word_files = set()
    expected_example_files = set()
    korean_words = {}  # Map original korean -> sanitized filename for mapping generation
    
    for word in words_data.values():
        if word.get("korean"):
            original = word["korean"]
            sanitized = sanitize_filename(original)
            korean_words[original] = sanitized
            expected_word_files.add(sanitized)
            
            # If there's an example sentence, expect example file too
            if word.get("korean_example_sentence"):
                expected_example_files.add(sanitized)
    
    # Find orphaned files by comparing actual vs expected
    orphaned_files = []
    orphaned_word_files = word_files - expected_word_files
    orphaned_example_files = example_files - expected_example_files
    
    for orphaned in orphaned_word_files:
        orphaned_files.append(f"words/{orphaned}.mp3")
    for orphaned in orphaned_example_files:
        orphaned_files.append(f"examples/{orphaned}.mp3")
    
    # Get valid files (intersection of actual and expected)
    valid_word_files = word_files & expected_word_files
    valid_example_files = example_files & expected_example_files
    
    # Write the mappings file
    with open(mappings_path, "w", encoding="utf-8") as f:
        f.write("// AUTO-GENERATED FILE - DO NOT EDIT\n")
        f.write("// This file is automatically generated by scripts/audio-generator/generate_mappings.py\n")
        f.write(f"// Last generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        
        # Write word audio mappings
        f.write("export const wordAudioMap = {\n")
        for original_korean, sanitized_filename in sorted(korean_words.items()):
            # Only include if the audio file actually exists
            if sanitized_filename in valid_word_files:
                # Escape single quotes and backslashes in the key (use original Korean)
                escaped_korean = original_korean.replace("\\", "\\\\").replace("'", "\\'")
                # Use sanitized filename for the require path
                escaped_path = sanitized_filename.replace("\\", "\\\\").replace("'", "\\'")
                f.write(f"  '{escaped_korean}': require('./audio/words/{escaped_path}.mp3'),\n")
        f.write("};\n\n")
        
        # Write example audio mappings
        f.write("export const exampleAudioMap = {\n")
        for original_korean, sanitized_filename in sorted(korean_words.items()):
            # Only include if the audio file actually exists
            if sanitized_filename in valid_example_files:
                # Escape single quotes and backslashes in the key (use original Korean)
                escaped_korean = original_korean.replace("\\", "\\\\").replace("'", "\\'")
                # Use sanitized filename for the require path
                escaped_path = sanitized_filename.replace("\\", "\\\\").replace("'", "\\'")
                f.write(f"  '{escaped_korean}': require('./audio/examples/{escaped_path}.mp3'),\n")
        f.write("};\n")
    
    return mappings_path, len(valid_word_files), len(valid_example_files), orphaned_files


def main():
    print("=== Audio Mapping Generator ===")
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 40)
    
    # Get the audio directory path
    audio_dir = os.path.join(
        os.path.dirname(__file__), "..", "..", "src", "assets", "audio"
    )
    
    if not os.path.exists(audio_dir):
        print(f"ERROR: Audio directory not found: {audio_dir}")
        print("Please run the audio generator script first.")
        return
    
    # Scan for existing audio files
    print(f"Scanning audio directory: {audio_dir}")
    word_files, example_files = scan_audio_files(audio_dir)
    
    print(f"\nFound audio files:")
    print(f"  - Word audio files: {len(word_files)}")
    print(f"  - Example audio files: {len(example_files)}")
    
    if not word_files and not example_files:
        print("\nNo audio files found! Please run the audio generator script first.")
        return
    
    # Create the mappings
    print("\nGenerating audio mappings...")
    mappings_path, valid_word_count, valid_example_count, orphaned = create_audio_mappings(word_files, example_files)
    
    print(f"\nCreated audio mappings file: {mappings_path}")
    print(f"  - Valid word mappings: {valid_word_count}")
    print(f"  - Valid example mappings: {valid_example_count}")
    
    if orphaned:
        print(f"\nWARNING: Found {len(orphaned)} orphaned audio files (no matching entry in words.json):")
        for file in orphaned[:10]:  # Show first 10
            print(f"  - {file}")
        if len(orphaned) > 10:
            print(f"  ... and {len(orphaned) - 10} more")
    
    # Show coverage statistics
    words_path = os.path.join(
        os.path.dirname(__file__), "..", "..", "src", "assets", "words.json"
    )
    with open(words_path, "r", encoding="utf-8") as f:
        words_data = json.load(f)
    
    total_words = len([w for w in words_data.values() if w.get("korean")])
    total_examples = len([w for w in words_data.values() if w.get("korean_example_sentence")])
    
    word_coverage = (valid_word_count / total_words * 100) if total_words > 0 else 0
    example_coverage = (valid_example_count / total_examples * 100) if total_examples > 0 else 0
    
    print(f"\nCoverage Statistics:")
    print(f"  - Words: {valid_word_count}/{total_words} ({word_coverage:.1f}%)")
    print(f"  - Examples: {valid_example_count}/{total_examples} ({example_coverage:.1f}%)")
    
    print("\nDone!")


if __name__ == "__main__":
    main()